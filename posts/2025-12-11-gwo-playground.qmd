---
title: "Interactive Grey Wolf Optimization"
author: "Ritwik Raha"
date: "2025-12-12"
format:
  html:
    page-layout: article
image: /assets/images/grey-wolf.gif
---

This is an interactive simulation of the Grey Wolf Optimizer (GWO) algorithm attempting to solve the **Rastrigin Function**. The global optimum is at the center `(0,0)`.

```{=html}
<style>
  /* Scoped styles for the playground */
  .gwo-wrapper {
    font-family: system-ui, -apple-system, sans-serif;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 20px;
    background-color: #f9f9f9;
    margin-top: 20px;
  }

  .gwo-container {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
  }

  .gwo-controls {
    flex: 1;
    min-width: 250px;
    background: #ffffff;
    padding: 15px;
    border-radius: 6px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }

  .gwo-canvas-box {
    flex: 0 0 auto;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #fff;
    border: 1px solid #ddd;
    border-radius: 6px;
    padding: 5px;
  }

  canvas {
    display: block;
    max-width: 100%;
    height: auto;
  }

  .control-group {
    margin-bottom: 15px;
  }

  .control-group label {
    display: flex;
    justify-content: space-between;
    font-weight: 600;
    font-size: 0.9em;
    margin-bottom: 5px;
    color: #333;
  }

  .control-group input[type="range"] {
    width: 100%;
    cursor: pointer;
  }

  .btn-restart {
    width: 100%;
    padding: 10px;
    background-color: #2563eb;
    color: white;
    border: none;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    transition: background 0.2s;
    margin-top: 10px;
  }

  .btn-restart:hover {
    background-color: #1d4ed8;
  }

  .stats-display {
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid #eee;
    font-family: monospace;
    font-size: 0.95em;
  }

  .legend-box {
    margin-top: 15px;
    font-size: 0.85em;
    color: #555;
    background: #f1f5f9;
    padding: 10px;
    border-radius: 4px;
  }

  .dot {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 5px;
  }
</style>

<div class="gwo-wrapper">
  <div class="gwo-container">
    
    <div class="gwo-controls">
      <div class="control-group">
        <label>Population Size <span id="val-pop">30</span></label>
        <input type="range" id="popSize" min="5" max="100" value="30">
      </div>
      
      <div class="control-group">
        <label>Max Iterations <span id="val-iter">500</span></label>
        <input type="range" id="maxIter" min="100" max="1000" step="10" value="500">
      </div>
      
      <div class="control-group">
        <label>Speed (FPS) <span id="val-speed">30</span></label>
        <input type="range" id="speed" min="1" max="60" value="30">
      </div>

      <button id="restartBtn" class="btn-restart">Restart Simulation</button>

      <div class="stats-display">
        <div><strong>Best Fitness:</strong> <span id="bestScore" style="color:#d32f2f;">Infinity</span></div>
        <div style="margin-top:5px;"><strong>Iteration:</strong> <span id="currentIter">0</span></div>
      </div>

      <div class="legend-box">
        <div><span class="dot" style="background:red;"></span>Alpha (Best)</div>
        <div><span class="dot" style="background:orange;"></span>Beta (2nd)</div>
        <div><span class="dot" style="background:gold;"></span>Delta (3rd)</div>
        <div><span class="dot" style="background:rgba(100,100,100,0.5);"></span>Omega (Pack)</div>
      </div>
    </div>

    <div class="gwo-canvas-box">
      <canvas id="simCanvas" width="500" height="500"></canvas>
    </div>
  </div>
</div>

<script>
// Encapsulate in IIFE to avoid global scope pollution
(function() {
  const canvas = document.getElementById('simCanvas');
  const ctx = canvas.getContext('2d');
  
  // Algorithm State
  let wolves = [];
  let alpha = { score: Infinity, x: 0, y: 0 };
  let beta = { score: Infinity, x: 0, y: 0 };
  let delta = { score: Infinity, x: 0, y: 0 };
  let iter = 0;
  let animationId;
  let isRunning = false;
  
  // Simulation Bounds (Rastrigin)
  const BOUNDS = 5.12;
  
  // User Parameters
  let params = {
    pop: 30,
    maxIter: 500,
    fps: 30
  };

  // UI Elements
  const ui = {
    pop: document.getElementById('popSize'),
    iter: document.getElementById('maxIter'),
    speed: document.getElementById('speed'),
    restart: document.getElementById('restartBtn'),
    valPop: document.getElementById('val-pop'),
    valIter: document.getElementById('val-iter'),
    valSpeed: document.getElementById('val-speed'),
    score: document.getElementById('bestScore'),
    cIter: document.getElementById('currentIter')
  };

  // Objective Function: Rastrigin
  function fitness(x, y) {
    const A = 10;
    return A * 2 + (x * x - A * Math.cos(2 * Math.PI * x)) + (y * y - A * Math.cos(2 * Math.PI * y));
  }

  // Helper: Map simulation coords to canvas pixels
  function toCanvas(x, y) {
    // Normalize x,y from [-5.12, 5.12] to [0, 1]
    const nx = (x + BOUNDS) / (2 * BOUNDS);
    const ny = (y + BOUNDS) / (2 * BOUNDS);
    
    // Scale to canvas size (flip Y because canvas 0 is top)
    return {
      x: nx * canvas.width,
      y: canvas.height - (ny * canvas.height)
    };
  }

  // Initialize Population
  function init() {
    wolves = [];
    for(let i = 0; i < params.pop; i++) {
      wolves.push({
        x: (Math.random() * 2 * BOUNDS) - BOUNDS,
        y: (Math.random() * 2 * BOUNDS) - BOUNDS,
        score: Infinity
      });
    }
    alpha = { score: Infinity };
    beta = { score: Infinity };
    delta = { score: Infinity };
    iter = 0;
    isRunning = true;
  }

  // Main Algorithm Loop
  function update() {
    // 1. Evaluate Fitness & Update Hierarchy
    for(let w of wolves) {
      // Boundary handling (clamping)
      w.x = Math.max(-BOUNDS, Math.min(BOUNDS, w.x));
      w.y = Math.max(-BOUNDS, Math.min(BOUNDS, w.y));
      
      const f = fitness(w.x, w.y);
      w.score = f;

      if(f < alpha.score) {
        alpha = {...w}; // Copy by value
      } else if(f < beta.score) {
        beta = {...w};
      } else if(f < delta.score) {
        delta = {...w};
      }
    }
    
    // Update Stats UI
    ui.score.innerText = alpha.score.toFixed(5);
    ui.cIter.innerText = `${iter} / ${params.maxIter}`;

    // 2. Update Positions
    const a = 2 - iter * (2 / params.maxIter); // Linear decrease
    
    for(let w of wolves) {
      // Helper to calculate new position dimension
      function updateDim(currentVal, leaderVal) {
        const r1 = Math.random();
        const r2 = Math.random();
        const A = 2 * a * r1 - a;
        const C = 2 * r2;
        const D = Math.abs(C * leaderVal - currentVal);
        return leaderVal - A * D;
      }
      
      // Calculate influence from Alpha, Beta, Delta
      const X1 = updateDim(w.x, alpha.x);
      const Y1 = updateDim(w.y, alpha.y);
      
      const X2 = updateDim(w.x, beta.x);
      const Y2 = updateDim(w.y, beta.y);
      
      const X3 = updateDim(w.x, delta.x);
      const Y3 = updateDim(w.y, delta.y);
      
      // Average the influences
      w.x = (X1 + X2 + X3) / 3;
      w.y = (Y1 + Y2 + Y3) / 3;
    }
    
    iter++;
  }

  function draw() {
    // Clear
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw Center/Grid
    const center = toCanvas(0,0);
    ctx.strokeStyle = "#eee";
    ctx.beginPath(); 
    ctx.moveTo(center.x, 0); ctx.lineTo(center.x, canvas.height);
    ctx.moveTo(0, center.y); ctx.lineTo(canvas.width, center.y);
    ctx.stroke();

    // Draw Wolves
    for(let w of wolves) {
      const p = toCanvas(w.x, w.y);
      ctx.beginPath();
      ctx.arc(p.x, p.y, 3, 0, 2*Math.PI);
      ctx.fillStyle = "rgba(100, 100, 100, 0.4)";
      ctx.fill();
    }
    
    // Draw Leaders
    function drawLeader(wolf, color, size) {
      if(wolf.score === Infinity) return;
      const p = toCanvas(wolf.x, wolf.y);
      ctx.beginPath();
      ctx.arc(p.x, p.y, size, 0, 2*Math.PI);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.strokeStyle = "white";
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    
    drawLeader(delta, "gold", 5);
    drawLeader(beta, "orange", 6);
    drawLeader(alpha, "red", 8);
  }

  function loop() {
    if(!isRunning) return;
    
    setTimeout(() => {
      if(iter < params.maxIter) {
        update();
        draw();
        animationId = requestAnimationFrame(loop);
      } else {
        isRunning = false; // Stop when max iter reached
      }
    }, 1000 / params.fps);
  }

  // Event Listeners
  ui.pop.oninput = (e) => { 
    params.pop = parseInt(e.target.value); 
    ui.valPop.innerText = params.pop; 
  };
  ui.iter.oninput = (e) => { 
    params.maxIter = parseInt(e.target.value); 
    ui.valIter.innerText = params.maxIter; 
  };
  ui.speed.oninput = (e) => { 
    params.fps = parseInt(e.target.value); 
    ui.valSpeed.innerText = params.fps; 
  };
  
  ui.restart.onclick = () => {
    isRunning = false;
    cancelAnimationFrame(animationId);
    // Short delay to ensure loop stops before restarting
    setTimeout(() => {
        init();
        loop();
    }, 50);
  };

  // Start immediately
  init();
  loop();

})();
</script>
```
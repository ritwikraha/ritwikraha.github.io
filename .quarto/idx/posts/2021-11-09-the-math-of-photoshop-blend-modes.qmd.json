{"title":"The Math of Photoshop Blend Modes","markdown":{"yaml":{"title":"The Math of Photoshop Blend Modes","date":"2021-11-09","author":"Ritwik Raha","tags":["math","image-processing"],"image":"/assets/images/4post/blend-modes-photoshop.gif"},"headingText":"Under the hood of blend modes","containsRefs":false,"markdown":"\n\nPhotoshop is a wonderful tool for working with images. It is a delight to work with as a designer and it is an instrument to marvel at as a Computer Vision engineer.\n\nBut the most used feature of Photoshop (atleast for me) is the blend-modes. From time immemorial I have wondered how these work and how do they create beautiful combination of images.\n\n![blend-modes](/assets/images/4post/blend-modes-photoshop.gif)\n\nIn this blog we will learn the following:\n\n- How do photoshop blend modes work?\n- The math behind *some* blend modes\n- Recreating blend modes using *python*\n\n\nTo begin with, let us first try to understand what is a *blend mode*. The idea is to *blend* two different images to produce a third image. Now there are different rules for blending and each of them results in a different output image. The easiest way to think of this is as a function.\n\n$$o = f(x,y)$$\n\nwhere $$x$$ and $$y$$ are the input images, $$o$$ is the output image, and the function is the process of blending.\n\n\n\n![blend-modes-operation](/assets/images/4post/blend-operation.gif)\n\n```Note: x and y represent color(RGB) values of the image```\n\nAs we devise different functions we will create different blend modes. Sounds simple right? \n\nLet us go through some blend modes and understand how they work:\n\n### Some simple blend modes\n\nIn this blog we will look at four simple blend modes:\n\n1. **Normal**\n2. **Multiply**\n3. **Screen**\n4. **Overlay**\n\nWe will also cover the mathematical intution for these modes and how to easily code them up using python. We load and display the images using ```OpenCV``` and ```matplotlib```. For the blending operations we use ```numpy```.\n\nYou can download the entire source code of this blogpost from [here](https://gist.github.com/ritwikraha/c1483e59d8501c3eca35fe0c5c8fcf86).\n\n**Normal**\n\nThe first one is always the most simple one. When two images are placed over each other this mode will choose to show only the top image. Mathematically we can express this like:\n\n$$f(x,y) = y$$\n\nThis is also called [alpha-composting](https://en.wikipedia.org/wiki/Alpha_compositing). It is relatively easy to code.\n\n```python \ndef normal(imgA,imgB):\n  # make a copy of the second image\n  imgBlended = np.copy(imgB)\n  # convert the image back into uint8 \n  imgOut=(imgBlended*255).astype(np.uint8)\n  # return the blended image\n  return imgOut\n```\n\nWe take two images and then create a copy of the second image. This image is passed back as output.\n\n**Multiply**\n\nNext we have the second most used blending mode. Before we go into the theory, imagine this:\n\nYou have the scanned signature of your parent and you want to place it on your leave application. You open up your image editing software and place the two images as you want them. But it does not look real. Something seems off. \n\nThis is where *multiply* comes in. This takes the value of each pixel of the first image and multiplies it with each corresponding pixel of the second image. The output image is darker across all pixels than either of the previous values. \n\nMathematically we can express this as:\n\n$$f(x,y) = xy$$\n\nThis is also quite easy to code up.\n\n```python \ndef multiply(imgA,imgB):\n  # create a container for the blended image\n  imgBlended = np.zeros_like(imgA)\n  # apply the blending formula to the images\n  imgBlended = imgA*imgB\n  # convert the image back into uint8\n  imgOut=(imgBlended*255).astype(np.uint8)\n  # return th blended image\n  return imgOut\n```\n\nIn the above method we first create a container to hold the blended image. Then we store the product of the two images and store it in ```imgBlended```. It is then converted back into ```uint8``` format and passed back.\n\n**Screen**\n\nNow the multiply blend mode makes the composite image look darker. What if we want the composite image to be brighter instead? \n\nYes we can simply invert what we did in the multiply blend mode to achieve that. First we invert the two images and multiply them. Then we invert the result. The formula would look something like this:\n\n$$f(x,y) = (1-(1-x)(1-y))$$\n\nLet us see how to express this in code:\n```python \ndef screen(imgA,imgB):\n  # create a container for the blended image\n  imgBlended = np.zeros_like(imgA)\n  # apply the blending formula to the images\n  imgBlended = (1-(1-imgA)*(1-imgB))\n  # convert the image back into uint8\n  imgOut=(imgBlended*255).astype(np.uint8)\n  # return the blended image\n  return imgOut\n```\nIn the above method we first create a container for the output image. Then we apply the operation to the two images and store the output in ```imgBlended```. It is then converted back into ```uint8``` format and passed back.\n\n**Overlay**\n\nLife is not seen in only light and dark and neither are images. While darkening and brightening an image are quite useful, it is also necessary to be adaptive. Overlay brings in the best of both blending modes. \n\nWhen the pixels of the first image is dark the pixels of the composite image is darker, when the pixels of the first image is light the pixels of the composite image is lighter. Usually the threshold is set at 0.5. The formula can be expressed as:\n\n$$f(x,y) = \\begin{cases}\n    2xy, & \\text{if $x<0.5$}.\\\\\n    1-2(1-a)(1-b), & \\text{otherwise}.\n  \\end{cases}$$\n\nLet us see how we can code this up:\n\n```python \ndef overlay(imgA,imgB):\n  # create a mask of the image A everywhere\n  # the pixels are greater than 0.5\n  mask = imgA >= 0.5\n  # create a container for the blended image\n  imgBlended = np.zeros_like(imgA)\n  # apply the blending formula to the mask\n  imgBlended[~mask] = (2*imgA*imgB)[~mask]\n  imgBlended[mask] = (1-2*(1-imgA)*(1-imgB))[mask]\n  # convert the image back into uint8\n  imgOut=(imgBlended*255).astype(np.uint8)\n  # return the blended image\n  return imgOut\n```\nIn the above method we create a mask for the threshold(wherever the first image has values over 0.5). Next we create a container for the blended image and store the belnd operation values in it. For everywhere other than the mask values we apply the ```multiply``` like operation and for everywhere else we apply the ```screen``` like operation.\n\n### Source Code\n\nYou can download the entire source code of this blogpost from [here](https://gist.github.com/ritwikraha/c1483e59d8501c3eca35fe0c5c8fcf86).\n\n\n### Conclusion\n\nThere we have it! Our first batch of photoshop like blend modes are now ready. And the best thing?\n\nWe built them from scracth! \n\nLet's see what our result looks like:\n\n![blend-modes-result](/assets/images/4post/output.png)\n\nNow, needless to say this barely scratches the surface. Real image processing applications like Photoshop have a lot going on under the hood. The calculations are much more streamlined and sophisticated. They also have an array of other blend modes.\n\n![blend-modes-result](/assets/images/4post/blend-modes.png)\n\n\n[This](https://github.com/flrs/blend_modes) repository aims to faithfully replicate these calculations to some degree. The actual literature of the blnd modes used by Adobe is also provided [here](https://www.adobe.com/content/dam/acom/en/devnet/pdf/pdf_reference_archive/blend_modes.pdf).\n\nHowever what we learned here today gives us a good starting point to understand and minimally recreate blend-modes.\n\n\n### References\n\n- [Image Blend Modes - Wikipedia](https://en.wikipedia.org/wiki/Blend_modes)\n- [Adobe Blend Modes Gudielines](https://www.adobe.com/content/dam/acom/en/devnet/pdf/pdf_reference_archive/blend_modes.pdf)\n- [Blending Modes Explained - Photoshop training channel](https://photoshoptrainingchannel.com/blending-modes-explained/)\n- [The Math behind Blend Modes - Imagineer](https://imagineer.in/blog/math-behind-blend-modes/)\n- [Blend Modes in Python](https://stackoverflow.com/questions/52141987/overlay-blending-mode-in-python-efficiently-as-possible-numpy-opencv)\n- [Pillow Blend Modes](https://blend-modes.readthedocs.io/_/downloads/en/latest/pdf/) ","srcMarkdownNoYaml":"\n\nPhotoshop is a wonderful tool for working with images. It is a delight to work with as a designer and it is an instrument to marvel at as a Computer Vision engineer.\n\nBut the most used feature of Photoshop (atleast for me) is the blend-modes. From time immemorial I have wondered how these work and how do they create beautiful combination of images.\n\n![blend-modes](/assets/images/4post/blend-modes-photoshop.gif)\n\nIn this blog we will learn the following:\n\n- How do photoshop blend modes work?\n- The math behind *some* blend modes\n- Recreating blend modes using *python*\n\n### Under the hood of blend modes\n\nTo begin with, let us first try to understand what is a *blend mode*. The idea is to *blend* two different images to produce a third image. Now there are different rules for blending and each of them results in a different output image. The easiest way to think of this is as a function.\n\n$$o = f(x,y)$$\n\nwhere $$x$$ and $$y$$ are the input images, $$o$$ is the output image, and the function is the process of blending.\n\n\n\n![blend-modes-operation](/assets/images/4post/blend-operation.gif)\n\n```Note: x and y represent color(RGB) values of the image```\n\nAs we devise different functions we will create different blend modes. Sounds simple right? \n\nLet us go through some blend modes and understand how they work:\n\n### Some simple blend modes\n\nIn this blog we will look at four simple blend modes:\n\n1. **Normal**\n2. **Multiply**\n3. **Screen**\n4. **Overlay**\n\nWe will also cover the mathematical intution for these modes and how to easily code them up using python. We load and display the images using ```OpenCV``` and ```matplotlib```. For the blending operations we use ```numpy```.\n\nYou can download the entire source code of this blogpost from [here](https://gist.github.com/ritwikraha/c1483e59d8501c3eca35fe0c5c8fcf86).\n\n**Normal**\n\nThe first one is always the most simple one. When two images are placed over each other this mode will choose to show only the top image. Mathematically we can express this like:\n\n$$f(x,y) = y$$\n\nThis is also called [alpha-composting](https://en.wikipedia.org/wiki/Alpha_compositing). It is relatively easy to code.\n\n```python \ndef normal(imgA,imgB):\n  # make a copy of the second image\n  imgBlended = np.copy(imgB)\n  # convert the image back into uint8 \n  imgOut=(imgBlended*255).astype(np.uint8)\n  # return the blended image\n  return imgOut\n```\n\nWe take two images and then create a copy of the second image. This image is passed back as output.\n\n**Multiply**\n\nNext we have the second most used blending mode. Before we go into the theory, imagine this:\n\nYou have the scanned signature of your parent and you want to place it on your leave application. You open up your image editing software and place the two images as you want them. But it does not look real. Something seems off. \n\nThis is where *multiply* comes in. This takes the value of each pixel of the first image and multiplies it with each corresponding pixel of the second image. The output image is darker across all pixels than either of the previous values. \n\nMathematically we can express this as:\n\n$$f(x,y) = xy$$\n\nThis is also quite easy to code up.\n\n```python \ndef multiply(imgA,imgB):\n  # create a container for the blended image\n  imgBlended = np.zeros_like(imgA)\n  # apply the blending formula to the images\n  imgBlended = imgA*imgB\n  # convert the image back into uint8\n  imgOut=(imgBlended*255).astype(np.uint8)\n  # return th blended image\n  return imgOut\n```\n\nIn the above method we first create a container to hold the blended image. Then we store the product of the two images and store it in ```imgBlended```. It is then converted back into ```uint8``` format and passed back.\n\n**Screen**\n\nNow the multiply blend mode makes the composite image look darker. What if we want the composite image to be brighter instead? \n\nYes we can simply invert what we did in the multiply blend mode to achieve that. First we invert the two images and multiply them. Then we invert the result. The formula would look something like this:\n\n$$f(x,y) = (1-(1-x)(1-y))$$\n\nLet us see how to express this in code:\n```python \ndef screen(imgA,imgB):\n  # create a container for the blended image\n  imgBlended = np.zeros_like(imgA)\n  # apply the blending formula to the images\n  imgBlended = (1-(1-imgA)*(1-imgB))\n  # convert the image back into uint8\n  imgOut=(imgBlended*255).astype(np.uint8)\n  # return the blended image\n  return imgOut\n```\nIn the above method we first create a container for the output image. Then we apply the operation to the two images and store the output in ```imgBlended```. It is then converted back into ```uint8``` format and passed back.\n\n**Overlay**\n\nLife is not seen in only light and dark and neither are images. While darkening and brightening an image are quite useful, it is also necessary to be adaptive. Overlay brings in the best of both blending modes. \n\nWhen the pixels of the first image is dark the pixels of the composite image is darker, when the pixels of the first image is light the pixels of the composite image is lighter. Usually the threshold is set at 0.5. The formula can be expressed as:\n\n$$f(x,y) = \\begin{cases}\n    2xy, & \\text{if $x<0.5$}.\\\\\n    1-2(1-a)(1-b), & \\text{otherwise}.\n  \\end{cases}$$\n\nLet us see how we can code this up:\n\n```python \ndef overlay(imgA,imgB):\n  # create a mask of the image A everywhere\n  # the pixels are greater than 0.5\n  mask = imgA >= 0.5\n  # create a container for the blended image\n  imgBlended = np.zeros_like(imgA)\n  # apply the blending formula to the mask\n  imgBlended[~mask] = (2*imgA*imgB)[~mask]\n  imgBlended[mask] = (1-2*(1-imgA)*(1-imgB))[mask]\n  # convert the image back into uint8\n  imgOut=(imgBlended*255).astype(np.uint8)\n  # return the blended image\n  return imgOut\n```\nIn the above method we create a mask for the threshold(wherever the first image has values over 0.5). Next we create a container for the blended image and store the belnd operation values in it. For everywhere other than the mask values we apply the ```multiply``` like operation and for everywhere else we apply the ```screen``` like operation.\n\n### Source Code\n\nYou can download the entire source code of this blogpost from [here](https://gist.github.com/ritwikraha/c1483e59d8501c3eca35fe0c5c8fcf86).\n\n\n### Conclusion\n\nThere we have it! Our first batch of photoshop like blend modes are now ready. And the best thing?\n\nWe built them from scracth! \n\nLet's see what our result looks like:\n\n![blend-modes-result](/assets/images/4post/output.png)\n\nNow, needless to say this barely scratches the surface. Real image processing applications like Photoshop have a lot going on under the hood. The calculations are much more streamlined and sophisticated. They also have an array of other blend modes.\n\n![blend-modes-result](/assets/images/4post/blend-modes.png)\n\n\n[This](https://github.com/flrs/blend_modes) repository aims to faithfully replicate these calculations to some degree. The actual literature of the blnd modes used by Adobe is also provided [here](https://www.adobe.com/content/dam/acom/en/devnet/pdf/pdf_reference_archive/blend_modes.pdf).\n\nHowever what we learned here today gives us a good starting point to understand and minimally recreate blend-modes.\n\n\n### References\n\n- [Image Blend Modes - Wikipedia](https://en.wikipedia.org/wiki/Blend_modes)\n- [Adobe Blend Modes Gudielines](https://www.adobe.com/content/dam/acom/en/devnet/pdf/pdf_reference_archive/blend_modes.pdf)\n- [Blending Modes Explained - Photoshop training channel](https://photoshoptrainingchannel.com/blending-modes-explained/)\n- [The Math behind Blend Modes - Imagineer](https://imagineer.in/blog/math-behind-blend-modes/)\n- [Blend Modes in Python](https://stackoverflow.com/questions/52141987/overlay-blending-mode-in-python-efficiently-as-possible-numpy-opencv)\n- [Pillow Blend Modes](https://blend-modes.readthedocs.io/_/downloads/en/latest/pdf/) "},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":false,"output-file":"2021-11-09-the-math-of-photoshop-blend-modes.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","title":"The Math of Photoshop Blend Modes","date":"2021-11-09","author":"Ritwik Raha","tags":["math","image-processing"],"image":"/assets/images/4post/blend-modes-photoshop.gif"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}